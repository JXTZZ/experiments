--- a/src/libponyc/codegen/genreference.c
+++ b/src/libponyc/codegen/genreference.c
@@ -137,7 +137,8 @@
 
   LLVMValueRef l_value = gen_expr(c, left);
 
-  if(l_value == NULL)
+  if((l_value == NULL) || (l_value == GEN_NOVALUE) ||
+    (l_value == GEN_NOTNEEDED))
     return NULL;
 
   ast_t* type = ast_type(ast);

--- a/src/libponyc/codegen/gentype.c
+++ b/src/libponyc/codegen/gentype.c
@@ -773,7 +773,7 @@
     {
       // Call the trace function indirectly depending on rcaps.
       LLVMValueRef value = LLVMBuildLoad(c->builder, field, "");
-      ast_t* field_type = t->fields[i].ast;
+      ast_t* field_type = t->fields[i].type->ast;
       value = gen_assign_cast(c, f_c_t->use_type, value, field_type);
       gentrace(c, ctx, value, value, field_type, field_type);
     } else {

--- a/src/libponyc/expr/reference.c
+++ b/src/libponyc/expr/reference.c
@@ -755,6 +755,7 @@
     type = ast_type(child);
   } else {
     type = ast_from(ast, TK_TUPLETYPE);
+    bool has_literal = false;
 
     while(child != NULL)
     {
@@ -762,24 +763,31 @@
       {
         ast_error(opt->check.errors, child,
           "a tuple can't contain an expression that jumps away with no value");
+        ast_free_unattached(type);
         return false;
       }
 
       ast_t* c_type = ast_type(child);
 
       if((c_type == NULL) || (ast_id(c_type) == TK_ERRORTYPE))
+      {
+        ast_free_unattached(type);
         return false;
+      }
 
       if(is_type_literal(c_type))
-      {
-        // At least one tuple member is literal, so whole tuple is
-        ast_free(type);
-        make_literal_type(ast);
-        return true;
-      }
+        has_literal = true;
 
       ast_append(type, c_type);
       child = ast_sibling(child);
+    }
+
+    if(has_literal)
+    {
+      // At least one tuple member is literal, so whole tuple is
+      ast_free_unattached(type);
+      make_literal_type(ast);
+      return true;
     }
   }
 
